---------------------------------------------------------------------
-- CONFIG
---------------------------------------------------------------------
local HOP_INTERVAL   = 30      -- alle 30s hoppen
local PLAYER_CAP     = 20      -- nur Server mit < 20 Spielern
local MAX_PER_PAGE   = 100     -- Roblox API Limit
local MAX_PAGES      = 25      -- bis ~2500 Server scannen
local RECENT_LIMIT   = 12      -- so viele letzte Server meiden
local REQUEST_RETRY  = 3       -- HTTP-Retries pro Seite
local DEBUG_LOG      = false

---------------------------------------------------------------------
-- SERVICES
---------------------------------------------------------------------
local Players         = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService     = game:GetService("HttpService")

local LP       = Players.LocalPlayer
local PLACE_ID = game.PlaceId
local JOB_ID   = game.JobId

---------------------------------------------------------------------
-- STATE (bei jedem Reload frisch)
---------------------------------------------------------------------
local AUTO_HOP_ENABLED = true
local killedOnce = false
local hopping    = false
local recentJobIds = { [JOB_ID] = true }

-- Sperrliste vom letzten Hop reinholen (persistiert über Teleports):
do
    local ok, json = pcall(function() return TeleportService:GetTeleportSetting("RecentJobs") end)
    if ok and type(json) == "string" and #json > 0 then
        local ok2, list = pcall(function() return HttpService:JSONDecode(json) end)
        if ok2 and type(list) == "table" then
            for _, id in ipairs(list) do recentJobIds[id] = true end
            recentJobIds[JOB_ID] = true
        end
    end
end

---------------------------------------------------------------------
-- Auto-Reexec nach Teleport (DEIN Loadstring)
---------------------------------------------------------------------
local function queueReexec()
    local q = (syn and syn.queue_on_teleport)
           or (queue_on_teleport)
           or (fluxus and fluxus.queue_on_teleport)
           or (KRNL_LOADED and queue_on_teleport)
    if q then
        q([[
            loadstring(game:HttpGet("https://raw.githubusercontent.com/kjhbdwadabfjkhgf/ajshgbdhb28/main/fefseffsefraweddaw"))()
        ]])
    elseif DEBUG_LOG then
        warn("[Hopper] queue_on_teleport nicht vorhanden – Reexec nicht möglich.")
    end
end

-- Nie hängen bleiben
TeleportService.TeleportInitFailed:Connect(function(_, result, msg)
    if DEBUG_LOG then warn("[Hopper] TeleportInitFailed:", tostring(result), msg or "") end
    hopping = false
end)
LP.CharacterAdded:Connect(function() killedOnce = false; hopping = false end)
task.spawn(function() while task.wait(10) do if hopping then hopping = false end end end)

---------------------------------------------------------------------
-- SWITCH (immer TRUE halten)
---------------------------------------------------------------------
local setSwitch
local sw = killTab:AddSwitch("Auto Hop (Best <20)", function(_)
    AUTO_HOP_ENABLED = true
    if setSwitch then pcall(function() setSwitch(true) end) end
end)
if sw then
    if sw.Set then setSwitch = function(v) sw:Set(v) end
    elseif sw.SetState then setSwitch = function(v) sw:SetState(v) end
    elseif sw.SetValue then setSwitch = function(v) sw:SetValue(v) end
    end
    pcall(function() if setSwitch then setSwitch(true) end end)
end
task.spawn(function()
    while task.wait(2) do
        AUTO_HOP_ENABLED = true
        if setSwitch then pcall(function() setSwitch(true) end) end
    end
end)

---------------------------------------------------------------------
-- HTTP (Exploit-Request bevorzugt; HttpService als Fallback)
---------------------------------------------------------------------
local requestImpl
do
    local exploitReq = rawget(getfenv(), "http_request")
                    or rawget(getfenv(), "request")
                    or (syn and syn.request)
    if exploitReq then
        requestImpl = function(url)
            local res = exploitReq({Url = url, Method = "GET"})
            if res and res.StatusCode and res.StatusCode >= 200 and res.StatusCode < 300 then
                return true, res.Body
            end
            return false, "HTTP "..tostring(res and res.StatusCode or "ERR")
        end
    else
        requestImpl = function(url)
            local ok, body = pcall(function() return HttpService:GetAsync(url, false) end)
            return ok, body
        end
    end
end

local function fetchPage(cursor)
    local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=%d%s")
        :format(PLACE_ID, MAX_PER_PAGE, cursor and ("&cursor=" .. cursor) or "")
    local tries = 0
    while tries < REQUEST_RETRY do
        tries = tries + 1
        local ok, body = requestImpl(url)
        if ok and body then return true, body end
        task.wait(0.25 * tries) -- Backoff
    end
    return false
end

---------------------------------------------------------------------
-- Beste Serverwahl: maximal „playing“ unter PLAYER_CAP, offene Slots, nicht in Sperrliste
---------------------------------------------------------------------
local function getBestServerUnderCap()
    local best, cursor, pages = nil, nil, 0
    repeat
        local ok, body = fetchPage(cursor)
        if not ok then break end

        local data; local okDec = pcall(function() data = HttpService:JSONDecode(body) end)
        if not okDec or not data or not data.data then break end

        for _, srv in ipairs(data.data) do
            local id      = srv.id
            local playing = tonumber(srv.playing) or 0
            local cap     = tonumber(srv.maxPlayers) or 0
            local open    = cap - playing
            if id and playing < PLAYER_CAP and open > 0 and not recentJobIds[id] and id ~= JOB_ID then
                if (not best) or (playing > best.playing) then
                    best = { id = id, playing = playing, cap = cap }
                end
            end
        end

        cursor = data.nextPageCursor   -- NICHT url-encoden
        pages  = pages + 1             -- (kein += in Lua)
        task.wait()                    -- yield
    until not cursor or pages >= MAX_PAGES or best

    if DEBUG_LOG then
        if best then print(("[Hopper] Best<%d: %s (%d/%d)"):format(PLAYER_CAP, best.id, best.playing, best.cap))
        else warn("[Hopper] Keine passende Instanz gefunden.") end
    end
    return best
end

---------------------------------------------------------------------
-- Sperrliste bauen und in TeleportSettings mitschicken
---------------------------------------------------------------------
local function buildRecentList(nextId)
    local list, count = {}, 0
    for id,_ in pairs(recentJobIds) do
        if id ~= nextId then
            table.insert(list, id)
            count = count + 1
            if count >= (RECENT_LIMIT - 1) then break end
        end
    end
    table.insert(list, nextId)
    return list
end

---------------------------------------------------------------------
-- Hop (gezielte Instanz + Reexec; nur hoppen, wenn ein passender Server existiert)
---------------------------------------------------------------------
local function hop(reason)
    if hopping or not AUTO_HOP_ENABLED then return end
    hopping = true

    local target = getBestServerUnderCap()
    if not target then
        -- kein passender Server gefunden -> nicht random rejoinen (sonst falscher Server);
        -- Timer versucht es wieder, oder Death-Hop beim nächsten Tod.
        hopping = false
        return
    end

    recentJobIds[target.id] = true
    local recentListJSON = HttpService:JSONEncode(buildRecentList(target.id))
    pcall(function()
        TeleportService:SetTeleportSetting("ServerHopperReason", reason)
        TeleportService:SetTeleportSetting("RecentJobs", recentListJSON)
    end)

    queueReexec() -- Script im Zielserver neu laden
    TeleportService:TeleportToPlaceInstance(PLACE_ID, target.id, LP)
end

---------------------------------------------------------------------
-- Death-Hop (beim ersten Tod)
---------------------------------------------------------------------
local function bindDeathHop(character)
    local hum = character:FindFirstChildOfClass("Humanoid")
    local function onDied()
        if not killedOnce then
            killedOnce = true
            hop("death")
        end
    end
    if hum then
        hum.Died:Connect(onDied)
    else
        character.ChildAdded:Connect(function(ch)
            if ch:IsA("Humanoid") and not killedOnce then
                ch.Died:Connect(onDied)
            end
        end)
    end
end
if LP.Character then bindDeathHop(LP.Character) end
LP.CharacterAdded:Connect(bindDeathHop)

---------------------------------------------------------------------
-- 30s-Timer (endlos)
---------------------------------------------------------------------
task.spawn(function()
    while true do
        task.wait(HOP_INTERVAL)
        if not hopping then hop("timer") end
    end
end)
