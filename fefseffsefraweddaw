-- == SERVICES UND GRUNDVARIABLEN ==
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/obeseinsect/roblox/main/Ui%20Libraries/Elerium.lua"))()
-- == GUI-FENSTER ==
local Window = library:AddWindow("Muki's private", {
    main_color = Color3.fromRGB(100, 100, 255),
    min_size = Vector2.new(400, 400),
    toggle_key = Enum.KeyCode.RightShift,
    can_resize = true,
})
local killTab = Window:AddTab("Auto Kill")
--ka logik
-- Services
local Players     = game:GetService("Players")
local RunService  = game:GetService("RunService")

local player   = Players.LocalPlayer
local char     = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local backpack = player:WaitForChild("Backpack")

-- Punch einmal sauber equippen (dein Snippet 1:1)
local punchTool = backpack:WaitForChild("Punch")
humanoid:EquipTool(punchTool)

-- Nach Respawn erneut setzen
player.CharacterAdded:Connect(function(newChar)
    char = newChar
    humanoid = char:WaitForChild("Humanoid")
    backpack = player:WaitForChild("Backpack")
    task.wait(0.3)
    local t = backpack:FindFirstChild("Punch")
    if t and t:IsA("Tool") then
        pcall(function() humanoid:EquipTool(t) end)
    end
end)

-- Switch: Auto Use (standardmäßig AN)
local autoUseEnabled = true
local switchWidget = killTab:AddSwitch("Auto Use Punch", function(state)
    autoUseEnabled = state
end)
pcall(function()
    if switchWidget and switchWidget.Set then
        switchWidget:Set(true) -- visuell auf AN
    end
end)

-- Tool-Use-Loop: ruft .Activate() auf dem aktuell ausgerüsteten Punch auf
local USE_INTERVAL = 0.12  -- dein Tool-Script throttlet zusätzlich über attackTime_upvr/tick()
local lastUse = 0

RunService.RenderStepped:Connect(function()
    if not autoUseEnabled then return end
    if not char then return end

    -- Sicherstellen, dass Punch ausgerüstet ist
    local equipped = char:FindFirstChildWhichIsA("Tool")
    if not equipped or equipped.Name ~= "Punch" then
        local t = backpack:FindFirstChild("Punch")
        if t and t:IsA("Tool") then
            pcall(function() humanoid:EquipTool(t) end)
        end
        equipped = char:FindFirstChildWhichIsA("Tool")
        if not equipped or equipped.Name ~= "Punch" then return end
    end

    -- Aktivieren -> triggert Parent.Activated in deinem Tool-Script
    local now = os.clock()
    if now - lastUse >= USE_INTERVAL then
        lastUse = now
        pcall(function() equipped:Activate() end)
    end
end)


--farm
local test = true
killTab:AddSwitch("Auto Kill", function(state)
    test = state
end)
RunService.RenderStepped:Connect(function()
    if not test then return end
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = character.HumanoidRootPart
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local db = plr.Character:FindFirstChild("DamageBox") or plr.Character:FindFirstChild("RightHand")
            if db and db:IsA("BasePart") then
                db.CFrame = hrp.CFrame * CFrame.new(0, 0, -2)
            end
        end
    end
end)


--autokill logik
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local backpack = player:WaitForChild("Backpack")

-- UI-Switch
local autoKillEnabled = true
killTab:AddSwitch("Auto Equip Punch", function(state)
    autoKillEnabled = state
    if autoKillEnabled then
        -- dein Equip-Snippet 1:1 ausgeführt
        local punchTool = backpack:WaitForChild("Punch")
        humanoid:EquipTool(punchTool)
    end
end)

-- falls du nach Respawn auch wieder equippen willst
player.CharacterAdded:Connect(function(newChar)
    char = newChar
    humanoid = char:WaitForChild("Humanoid")
    backpack = player:WaitForChild("Backpack")
    if autoKillEnabled then
        local punchTool = backpack:WaitForChild("Punch")
        humanoid:EquipTool(punchTool)
    end
end)
---------------------------------------------------------------------
-- SETTINGS
---------------------------------------------------------------------
local HOP_INTERVAL = 30         -- alle 30s
local PLAYER_CAP   = 20         -- nur Server mit <20 Spielern
local MAX_PER_PAGE = 100        -- Roblox API Limit
local MAX_PAGES    = 20         -- bis ~2000 Server scannen
local DEBUG_LOG    = false      -- bei Bedarf true

---------------------------------------------------------------------
-- SERVICES
---------------------------------------------------------------------
local Players         = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService     = game:GetService("HttpService")

local LP       = Players.LocalPlayer
local PLACE_ID = game.PlaceId
local JOB_ID   = game.JobId

---------------------------------------------------------------------
-- STATE (bei jedem Reload frisch)
---------------------------------------------------------------------
local AUTO_HOP_ENABLED = true
local killedOnce = false
local hopping    = false
local seenJobs   = {[JOB_ID] = true}  -- meidet aktuellen Server

---------------------------------------------------------------------
-- AUTO-REEXEC (DEIN LOADSTRING)
---------------------------------------------------------------------
local function queueReexec()
    local q = (syn and syn.queue_on_teleport)
           or (queue_on_teleport)
           or (fluxus and fluxus.queue_on_teleport)
    if q then
        q([[
            loadstring(game:HttpGet("https://raw.githubusercontent.com/kjhbdwadabfjkhgf/ajshgbdhb28/main/fefseffsefraweddaw"))()
        ]])
    elseif DEBUG_LOG then
        warn("[Hopper] queue_on_teleport nicht verfügbar (Script startet im Zielserver nicht neu).")
    end
end

-- niemals hängen bleiben
TeleportService.TeleportInitFailed:Connect(function(_, result, msg)
    if DEBUG_LOG then warn("[Hopper] TeleportInitFailed:", tostring(result), msg or "") end
    hopping = false
end)
LP.CharacterAdded:Connect(function()
    killedOnce = false
    hopping = false
end)

---------------------------------------------------------------------
-- SWITCH (immer TRUE halten)
---------------------------------------------------------------------
local setSwitch
local sw = killTab:AddSwitch("Auto Hop (Best <20)", function(_)
    AUTO_HOP_ENABLED = true
    if setSwitch then pcall(function() setSwitch(true) end) end
end)
if sw then
    if sw.Set then setSwitch = function(v) sw:Set(v) end
    elseif sw.SetState then setSwitch = function(v) sw:SetState(v) end
    elseif sw.SetValue then setSwitch = function(v) sw:SetValue(v) end
    end
    pcall(function() if setSwitch then setSwitch(true) end end)
end
task.spawn(function()
    while task.wait(2) do
        AUTO_HOP_ENABLED = true
        if setSwitch then pcall(function() setSwitch(true) end) end
    end
end)

---------------------------------------------------------------------
-- HTTP (Exploit-Request bevorzugt; HttpService als Fallback)
---------------------------------------------------------------------
local requestImpl
do
    local exploitReq = rawget(getfenv(), "http_request")
                    or rawget(getfenv(), "request")
                    or (syn and syn.request)
    if exploitReq then
        requestImpl = function(url)
            local res = exploitReq({Url = url, Method = "GET"})
            if res and res.StatusCode and res.StatusCode >= 200 and res.StatusCode < 300 then
                return true, res.Body
            end
            return false, "HTTP "..tostring(res and res.StatusCode or "ERR")
        end
    else
        -- Achtung: In Live-Games ist GetAsync oft blockiert. Wenn es false liefert, gibt's unten einen Fallback.
        requestImpl = function(url)
            local ok, body = pcall(function() return HttpService:GetAsync(url, false) end)
            return ok, body
        end
    end
end

local function fetchPage(cursor)
    local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=%d%s")
        :format(PLACE_ID, MAX_PER_PAGE, cursor and ("&cursor=" .. cursor) or "")
    local ok, body = requestImpl(url)
    if not ok or not body then return nil end
    local data; local okDec = pcall(function() data = HttpService:JSONDecode(body) end)
    if not okDec or not data or not data.data then return nil end
    return data
end

---------------------------------------------------------------------
-- BESTER SERVER <20 (maximales 'playing', offene Slots, nicht aktueller/gesperrter)
---------------------------------------------------------------------
local function getBestServerUnderCap()
    local best, cursor, pages = nil, nil, 0
    repeat
        local data = fetchPage(cursor)
        if not data then break end

        for _, srv in ipairs(data.data) do
            local id      = srv.id
            local playing = tonumber(srv.playing) or 0
            local cap     = tonumber(srv.maxPlayers) or 0
            local open    = cap - playing
            if id and not seenJobs[id] and id ~= JOB_ID and open > 0 and playing < PLAYER_CAP then
                if (not best) or (playing > best.playing) then
                    best = { id = id, playing = playing, cap = cap }
                end
            end
        end

        cursor = data.nextPageCursor          -- NICHT url-encoden
        pages  = pages + 1                    -- (kein += in Lua)
        task.wait()                           -- yield
    until not cursor or pages >= MAX_PAGES or best

    if DEBUG_LOG then
        if best then
            print(("[Hopper] Best<%d -> %s (%d/%d)"):format(PLAYER_CAP, best.id, best.playing, best.cap))
        else
            warn("[Hopper] Keine passende Instanz gefunden.")
        end
    end
    return best
end

---------------------------------------------------------------------
-- HOP (immer gezielt; wenn HTTP blockiert → einmaliger Fallback)
---------------------------------------------------------------------
local function hop(reason)
    if hopping or not AUTO_HOP_ENABLED then return end
    hopping = true

    local target = getBestServerUnderCap()
    if target and target.id then
        seenJobs[target.id] = true
        pcall(function() TeleportService:SetTeleportSetting("ServerHopperReason", reason) end)
        queueReexec()
        TeleportService:TeleportToPlaceInstance(PLACE_ID, target.id, LP)
        return
    end

    -- Fallback NUR wenn keine API greift – damit trotzdem ein Wechsel passiert
    if DEBUG_LOG then warn("[Hopper] Fallback auf normalen Teleport (API leer/blockiert).") end
    queueReexec()
    TeleportService:Teleport(PLACE_ID, LP)
end

---------------------------------------------------------------------
-- DEATH-HOP (beim ersten Tod)
---------------------------------------------------------------------
local function bindDeathHop(character)
    local hum = character:FindFirstChildOfClass("Humanoid")
    local function onDied()
        if not killedOnce then
            killedOnce = true
            hop("death")
        end
    end
    if hum then
        hum.Died:Connect(onDied)
    else
        character.ChildAdded:Connect(function(ch)
            if ch:IsA("Humanoid") and not killedOnce then
                ch.Died:Connect(onDied)
            end
        end)
    end
end
if LP.Character then bindDeathHop(LP.Character) end
LP.CharacterAdded:Connect(bindDeathHop)

---------------------------------------------------------------------
-- 30s TIMER (endlos)
---------------------------------------------------------------------
task.spawn(function()
    while true do
        task.wait(HOP_INTERVAL)
        if not hopping then hop("timer") end
    end
end)
